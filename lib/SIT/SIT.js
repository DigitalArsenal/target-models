// automatically generated by the FlatBuffers compiler, do not modify
import * as flatbuffers from 'flatbuffers';
import { DataMode } from './DataMode.js';
import { Geometry } from './Geometry.js';
import { SensorData } from './SensorData.js';
/**
 * Site Information Message
 */
export class SIT {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSIT(bb, obj) {
        return (obj || new SIT()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSIT(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SIT()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$SIT');
    }
    /**
     * Latitude of the site
     */
    LATITUDE() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Longitude of the site
     */
    LONGITUDE() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Altitude of the site
     */
    ALTITUDE() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Geometry of the site
     */
    GEOMETRY(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new Geometry()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * Center point geometry coordinates
     */
    CENTER_POINT_GEOMETRY(index) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
    centerPointGeometryLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    centerPointGeometryArray() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    CLASSIFICATION(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    COUNTRY(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    CREATED_BY(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Mode of the site data
     */
    DATA_MODE() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : DataMode.real;
    }
    ID_SENSOR(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Magnitude limit at the site
     */
    MAGNITUDE_LIMIT() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    SENSOR_NAME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Number of the sensor
     */
    SENSOR_NUMBER() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * Statistical data of the sensor
     */
    SENSOR_STATS(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? (obj || new SensorData()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    sensorStatsLength() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Collection of sensor limits
     */
    SENSOR_LIMITS_COLLECTION(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? (obj || new SensorData()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    sensorLimitsCollectionLength() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    SENSOR_TYPE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    SENSOR_TYPE_SHORT(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Characteristics of the sensor
     */
    SENSOR_CHARACTERISTICS(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? (obj || new SensorData()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    sensorCharacteristicsLength() {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    SOURCE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 40);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Indicates if the site is taskable
     */
    TASKABLE() {
        const offset = this.bb.__offset(this.bb_pos, 42);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startSIT(builder) {
        builder.startObject(20);
    }
    static addLatitude(builder, LATITUDE) {
        builder.addFieldFloat32(0, LATITUDE, 0.0);
    }
    static addLongitude(builder, LONGITUDE) {
        builder.addFieldFloat32(1, LONGITUDE, 0.0);
    }
    static addAltitude(builder, ALTITUDE) {
        builder.addFieldFloat32(2, ALTITUDE, 0.0);
    }
    static addGeometry(builder, GEOMETRYOffset) {
        builder.addFieldOffset(3, GEOMETRYOffset, 0);
    }
    static addCenterPointGeometry(builder, CENTER_POINT_GEOMETRYOffset) {
        builder.addFieldOffset(4, CENTER_POINT_GEOMETRYOffset, 0);
    }
    static createCenterPointGeometryVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat32(data[i]);
        }
        return builder.endVector();
    }
    static startCenterPointGeometryVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addClassification(builder, CLASSIFICATIONOffset) {
        builder.addFieldOffset(5, CLASSIFICATIONOffset, 0);
    }
    static addCountry(builder, COUNTRYOffset) {
        builder.addFieldOffset(6, COUNTRYOffset, 0);
    }
    static addCreatedBy(builder, CREATED_BYOffset) {
        builder.addFieldOffset(7, CREATED_BYOffset, 0);
    }
    static addDataMode(builder, DATA_MODE) {
        builder.addFieldInt8(8, DATA_MODE, DataMode.real);
    }
    static addIdSensor(builder, ID_SENSOROffset) {
        builder.addFieldOffset(9, ID_SENSOROffset, 0);
    }
    static addMagnitudeLimit(builder, MAGNITUDE_LIMIT) {
        builder.addFieldFloat64(10, MAGNITUDE_LIMIT, 0.0);
    }
    static addSensorName(builder, SENSOR_NAMEOffset) {
        builder.addFieldOffset(11, SENSOR_NAMEOffset, 0);
    }
    static addSensorNumber(builder, SENSOR_NUMBER) {
        builder.addFieldInt32(12, SENSOR_NUMBER, 0);
    }
    static addSensorStats(builder, SENSOR_STATSOffset) {
        builder.addFieldOffset(13, SENSOR_STATSOffset, 0);
    }
    static createSensorStatsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startSensorStatsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addSensorLimitsCollection(builder, SENSOR_LIMITS_COLLECTIONOffset) {
        builder.addFieldOffset(14, SENSOR_LIMITS_COLLECTIONOffset, 0);
    }
    static createSensorLimitsCollectionVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startSensorLimitsCollectionVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addSensorType(builder, SENSOR_TYPEOffset) {
        builder.addFieldOffset(15, SENSOR_TYPEOffset, 0);
    }
    static addSensorTypeShort(builder, SENSOR_TYPE_SHORTOffset) {
        builder.addFieldOffset(16, SENSOR_TYPE_SHORTOffset, 0);
    }
    static addSensorCharacteristics(builder, SENSOR_CHARACTERISTICSOffset) {
        builder.addFieldOffset(17, SENSOR_CHARACTERISTICSOffset, 0);
    }
    static createSensorCharacteristicsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startSensorCharacteristicsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addSource(builder, SOURCEOffset) {
        builder.addFieldOffset(18, SOURCEOffset, 0);
    }
    static addTaskable(builder, TASKABLE) {
        builder.addFieldInt8(19, +TASKABLE, +false);
    }
    static endSIT(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishSITBuffer(builder, offset) {
        builder.finish(offset, '$SIT');
    }
    static finishSizePrefixedSITBuffer(builder, offset) {
        builder.finish(offset, '$SIT', true);
    }
    unpack() {
        return new SITT(this.LATITUDE(), this.LONGITUDE(), this.ALTITUDE(), (this.GEOMETRY() !== null ? this.GEOMETRY().unpack() : null), this.bb.createScalarList(this.CENTER_POINT_GEOMETRY.bind(this), this.centerPointGeometryLength()), this.CLASSIFICATION(), this.COUNTRY(), this.CREATED_BY(), this.DATA_MODE(), this.ID_SENSOR(), this.MAGNITUDE_LIMIT(), this.SENSOR_NAME(), this.SENSOR_NUMBER(), this.bb.createObjList(this.SENSOR_STATS.bind(this), this.sensorStatsLength()), this.bb.createObjList(this.SENSOR_LIMITS_COLLECTION.bind(this), this.sensorLimitsCollectionLength()), this.SENSOR_TYPE(), this.SENSOR_TYPE_SHORT(), this.bb.createObjList(this.SENSOR_CHARACTERISTICS.bind(this), this.sensorCharacteristicsLength()), this.SOURCE(), this.TASKABLE());
    }
    unpackTo(_o) {
        _o.LATITUDE = this.LATITUDE();
        _o.LONGITUDE = this.LONGITUDE();
        _o.ALTITUDE = this.ALTITUDE();
        _o.GEOMETRY = (this.GEOMETRY() !== null ? this.GEOMETRY().unpack() : null);
        _o.CENTER_POINT_GEOMETRY = this.bb.createScalarList(this.CENTER_POINT_GEOMETRY.bind(this), this.centerPointGeometryLength());
        _o.CLASSIFICATION = this.CLASSIFICATION();
        _o.COUNTRY = this.COUNTRY();
        _o.CREATED_BY = this.CREATED_BY();
        _o.DATA_MODE = this.DATA_MODE();
        _o.ID_SENSOR = this.ID_SENSOR();
        _o.MAGNITUDE_LIMIT = this.MAGNITUDE_LIMIT();
        _o.SENSOR_NAME = this.SENSOR_NAME();
        _o.SENSOR_NUMBER = this.SENSOR_NUMBER();
        _o.SENSOR_STATS = this.bb.createObjList(this.SENSOR_STATS.bind(this), this.sensorStatsLength());
        _o.SENSOR_LIMITS_COLLECTION = this.bb.createObjList(this.SENSOR_LIMITS_COLLECTION.bind(this), this.sensorLimitsCollectionLength());
        _o.SENSOR_TYPE = this.SENSOR_TYPE();
        _o.SENSOR_TYPE_SHORT = this.SENSOR_TYPE_SHORT();
        _o.SENSOR_CHARACTERISTICS = this.bb.createObjList(this.SENSOR_CHARACTERISTICS.bind(this), this.sensorCharacteristicsLength());
        _o.SOURCE = this.SOURCE();
        _o.TASKABLE = this.TASKABLE();
    }
}
export class SITT {
    constructor(LATITUDE = 0.0, LONGITUDE = 0.0, ALTITUDE = 0.0, GEOMETRY = null, CENTER_POINT_GEOMETRY = [], CLASSIFICATION = null, COUNTRY = null, CREATED_BY = null, DATA_MODE = DataMode.real, ID_SENSOR = null, MAGNITUDE_LIMIT = 0.0, SENSOR_NAME = null, SENSOR_NUMBER = 0, SENSOR_STATS = [], SENSOR_LIMITS_COLLECTION = [], SENSOR_TYPE = null, SENSOR_TYPE_SHORT = null, SENSOR_CHARACTERISTICS = [], SOURCE = null, TASKABLE = false) {
        this.LATITUDE = LATITUDE;
        this.LONGITUDE = LONGITUDE;
        this.ALTITUDE = ALTITUDE;
        this.GEOMETRY = GEOMETRY;
        this.CENTER_POINT_GEOMETRY = CENTER_POINT_GEOMETRY;
        this.CLASSIFICATION = CLASSIFICATION;
        this.COUNTRY = COUNTRY;
        this.CREATED_BY = CREATED_BY;
        this.DATA_MODE = DATA_MODE;
        this.ID_SENSOR = ID_SENSOR;
        this.MAGNITUDE_LIMIT = MAGNITUDE_LIMIT;
        this.SENSOR_NAME = SENSOR_NAME;
        this.SENSOR_NUMBER = SENSOR_NUMBER;
        this.SENSOR_STATS = SENSOR_STATS;
        this.SENSOR_LIMITS_COLLECTION = SENSOR_LIMITS_COLLECTION;
        this.SENSOR_TYPE = SENSOR_TYPE;
        this.SENSOR_TYPE_SHORT = SENSOR_TYPE_SHORT;
        this.SENSOR_CHARACTERISTICS = SENSOR_CHARACTERISTICS;
        this.SOURCE = SOURCE;
        this.TASKABLE = TASKABLE;
    }
    pack(builder) {
        const GEOMETRY = (this.GEOMETRY !== null ? this.GEOMETRY.pack(builder) : 0);
        const CENTER_POINT_GEOMETRY = SIT.createCenterPointGeometryVector(builder, this.CENTER_POINT_GEOMETRY);
        const CLASSIFICATION = (this.CLASSIFICATION !== null ? builder.createString(this.CLASSIFICATION) : 0);
        const COUNTRY = (this.COUNTRY !== null ? builder.createString(this.COUNTRY) : 0);
        const CREATED_BY = (this.CREATED_BY !== null ? builder.createString(this.CREATED_BY) : 0);
        const ID_SENSOR = (this.ID_SENSOR !== null ? builder.createString(this.ID_SENSOR) : 0);
        const SENSOR_NAME = (this.SENSOR_NAME !== null ? builder.createString(this.SENSOR_NAME) : 0);
        const SENSOR_STATS = SIT.createSensorStatsVector(builder, builder.createObjectOffsetList(this.SENSOR_STATS));
        const SENSOR_LIMITS_COLLECTION = SIT.createSensorLimitsCollectionVector(builder, builder.createObjectOffsetList(this.SENSOR_LIMITS_COLLECTION));
        const SENSOR_TYPE = (this.SENSOR_TYPE !== null ? builder.createString(this.SENSOR_TYPE) : 0);
        const SENSOR_TYPE_SHORT = (this.SENSOR_TYPE_SHORT !== null ? builder.createString(this.SENSOR_TYPE_SHORT) : 0);
        const SENSOR_CHARACTERISTICS = SIT.createSensorCharacteristicsVector(builder, builder.createObjectOffsetList(this.SENSOR_CHARACTERISTICS));
        const SOURCE = (this.SOURCE !== null ? builder.createString(this.SOURCE) : 0);
        SIT.startSIT(builder);
        SIT.addLatitude(builder, this.LATITUDE);
        SIT.addLongitude(builder, this.LONGITUDE);
        SIT.addAltitude(builder, this.ALTITUDE);
        SIT.addGeometry(builder, GEOMETRY);
        SIT.addCenterPointGeometry(builder, CENTER_POINT_GEOMETRY);
        SIT.addClassification(builder, CLASSIFICATION);
        SIT.addCountry(builder, COUNTRY);
        SIT.addCreatedBy(builder, CREATED_BY);
        SIT.addDataMode(builder, this.DATA_MODE);
        SIT.addIdSensor(builder, ID_SENSOR);
        SIT.addMagnitudeLimit(builder, this.MAGNITUDE_LIMIT);
        SIT.addSensorName(builder, SENSOR_NAME);
        SIT.addSensorNumber(builder, this.SENSOR_NUMBER);
        SIT.addSensorStats(builder, SENSOR_STATS);
        SIT.addSensorLimitsCollection(builder, SENSOR_LIMITS_COLLECTION);
        SIT.addSensorType(builder, SENSOR_TYPE);
        SIT.addSensorTypeShort(builder, SENSOR_TYPE_SHORT);
        SIT.addSensorCharacteristics(builder, SENSOR_CHARACTERISTICS);
        SIT.addSource(builder, SOURCE);
        SIT.addTaskable(builder, this.TASKABLE);
        return SIT.endSIT(builder);
    }
}
